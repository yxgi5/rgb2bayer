#ifndef _VCROP_H_
#define _VCROP_H_
	
	#include <hls_video.h>
	//#include "ap_cint.h"

//// 8bit 1spc
//#define MDW 8 // M Data width
//#define R_shift 8*2
//#define B_mask 0xff
//#define B_shift 8
//#define SDW 24 // S Data width

//// 10bit 1spc
//#define MDW 16 // M Data width
//#define R_shift 10*2
//#define B_mask 0x3ff
//#define B_shift 10
//#define SDW 32 // S Data width

//// 12bit 1spc
//#define MDW 16 // M Data width
//#define R_shift 12*2
//#define B_mask 0xfff
//#define B_shift 12
//#define SDW 40 // S Data width

//// 16bit 1spc
//#define MDW 16 // M Data width
//#define R_shift 16*2
//#define B_mask 0xffff
//#define B_shift 16
//#define SDW 48 // S Data width

// 8bit 2spc
#define SAMPLES_PER_CLOCK 2
#define MAXIMUM_DATA_WIDTH 10
#define NUM_VIDEO_COMPONENTS 3

#define S_AXIS_WIDTH ((SAMPLES_PER_CLOCK*MAXIMUM_DATA_WIDTH*NUM_VIDEO_COMPONENTS+7)/8)*8 // S Data width
#define S_AXIS_BYTES ((SAMPLES_PER_CLOCK*MAXIMUM_DATA_WIDTH*NUM_VIDEO_COMPONENTS+7)/8)

#define M_AXIS_WIDTH ((SAMPLES_PER_CLOCK*MAXIMUM_DATA_WIDTH+7)/8) * 8 // M Data width
#define M_AXIS_BYTES ((SAMPLES_PER_CLOCK*MAXIMUM_DATA_WIDTH+7)/8)

//在python用这样的的表达式计算
//s1=int((SAMPLES_PER_CLOCK*MAXIMUM_DATA_WIDTH*NUM_VIDEO_COMPONENTS+7)/8)*8

//SAMPLES_PER_CLOCK==1 && MAXIMUM_DATA_WIDTH==8
//S_AXIS_WIDTH==24
//S_AXIS_BYTES==3
//M_AXIS_WIDTH==8
//M_AXIS_WIDTH==1

//SAMPLES_PER_CLOCK==1 && MAXIMUM_DATA_WIDTH==10
//S_AXIS_WIDTH==32
//S_AXIS_BYTES==4
//M_AXIS_WIDTH==16
//M_AXIS_WIDTH==2

//SAMPLES_PER_CLOCK==1 && MAXIMUM_DATA_WIDTH==12
//S_AXIS_WIDTH==40
//S_AXIS_BYTES==5
//M_AXIS_WIDTH==16
//M_AXIS_WIDTH==2

//SAMPLES_PER_CLOCK==1 && MAXIMUM_DATA_WIDTH==16
//S_AXIS_WIDTH==48
//S_AXIS_BYTES==6
//M_AXIS_WIDTH==16
//M_AXIS_WIDTH==2

//SAMPLES_PER_CLOCK==2 && MAXIMUM_DATA_WIDTH==8
//S_AXIS_WIDTH==48
//S_AXIS_BYTES==6
//M_AXIS_WIDTH==16
//M_AXIS_WIDTH==2

//SAMPLES_PER_CLOCK==2 && MAXIMUM_DATA_WIDTH==10
//S_AXIS_WIDTH==64
//S_AXIS_BYTES==8
//M_AXIS_WIDTH==24
//M_AXIS_WIDTH==3

//SAMPLES_PER_CLOCK==2 && MAXIMUM_DATA_WIDTH==12
//S_AXIS_WIDTH==72
//S_AXIS_BYTES==9
//M_AXIS_WIDTH==24
//M_AXIS_WIDTH==3

//SAMPLES_PER_CLOCK==2 && MAXIMUM_DATA_WIDTH==16
//S_AXIS_WIDTH==96
//S_AXIS_BYTES==12
//M_AXIS_WIDTH==32
//M_AXIS_WIDTH==4

//SAMPLES_PER_CLOCK==4 && MAXIMUM_DATA_WIDTH==8
//S_AXIS_WIDTH==96
//S_AXIS_BYTES==12
//M_AXIS_WIDTH==32
//M_AXIS_WIDTH==4

//SAMPLES_PER_CLOCK==4 && MAXIMUM_DATA_WIDTH==10
//S_AXIS_WIDTH==120
//S_AXIS_BYTES==15
//M_AXIS_WIDTH==40
//M_AXIS_WIDTH==5

//SAMPLES_PER_CLOCK==4 && MAXIMUM_DATA_WIDTH==12
//S_AXIS_WIDTH==144
//S_AXIS_BYTES==18
//M_AXIS_WIDTH==48
//M_AXIS_WIDTH==6

//SAMPLES_PER_CLOCK==4 && MAXIMUM_DATA_WIDTH==16
//S_AXIS_WIDTH==192
//S_AXIS_BYTES==24
//M_AXIS_WIDTH==64
//M_AXIS_WIDTH==8

//SAMPLES_PER_CLOCK==8 && MAXIMUM_DATA_WIDTH==8
//S_AXIS_WIDTH==192
//S_AXIS_BYTES==24
//M_AXIS_WIDTH==64
//M_AXIS_WIDTH==8

//SAMPLES_PER_CLOCK==8 && MAXIMUM_DATA_WIDTH==10
//S_AXIS_WIDTH==240
//S_AXIS_BYTES==30
//M_AXIS_WIDTH==80
//M_AXIS_WIDTH==10

//SAMPLES_PER_CLOCK==8 && MAXIMUM_DATA_WIDTH==12
//S_AXIS_WIDTH==288
//S_AXIS_BYTES==36
//M_AXIS_WIDTH==96
//M_AXIS_WIDTH==12

//SAMPLES_PER_CLOCK==8 && MAXIMUM_DATA_WIDTH==16
//S_AXIS_WIDTH==384
//S_AXIS_BYTES==48
//M_AXIS_WIDTH==128
//M_AXIS_WIDTH==16


	typedef hls::stream<ap_axiu<S_AXIS_WIDTH,1,1,1> >		AXI_STREAM1;
	typedef hls::stream<ap_axiu<M_AXIS_WIDTH,1,1,1> >		AXI_STREAM2;
//	typedef hls::stream<ap_axis<24,1,1,1> >		AXI_STREAM1;
//	typedef hls::stream<ap_axis<8,1,1,1> >		AXI_STREAM2;

	void rgb2bayer(AXI_STREAM1& s_axis_video,AXI_STREAM2& m_axis_video, int hsize_in, int vsize_in, ap_uint<2> pattern);
#endif
